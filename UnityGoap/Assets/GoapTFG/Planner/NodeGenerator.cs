using System;
using System.Collections.Generic;
using System.Linq;
using GoapTFG.Base;

namespace GoapTFG.Planner
{
    public class NodeGenerator<TA, TB>
    {
        private Node<TA, TB> _current;
        private readonly List<Node<TA, TB>> _openList;
        private readonly HashSet<Node<TA, TB>> _expandedNodes;
        private readonly Dictionary<Node<TA, TB>, int> _expandedNodesCosts;

        private NodeGenerator()
        {
            _openList = new List<Node<TA, TB>>();
            _expandedNodes = new HashSet<Node<TA, TB>>();
            _expandedNodesCosts = new Dictionary<Node<TA, TB>, int>();
        }

        public static List<Base.Action<TA, TB>> CreatePlan(PropertyGroup<TA, TB> currentState, Goal<TA, TB> goal,
            List<Base.Action<TA, TB>> actions)
        {
            NodeGenerator<TA, TB> planner = new NodeGenerator<TA, TB>();
            return planner.DoCreatePlan(currentState, goal, actions);
        }

        /// <summary>
        /// Creates a plan that finds using A* the path that finds the cheapest way to reach it.
        /// </summary>
        private List<Base.Action<TA, TB>> DoCreatePlan(PropertyGroup<TA, TB> currentState, Goal<TA, TB> goal,
            List<Base.Action<TA, TB>> actions)
        {
            if (currentState == null || goal == null || actions == null) throw new ArgumentNullException();
            if (actions.Count == 0) return null;
            
            _current = new Node<TA, TB>(currentState);
            while (_current != null && !_current.IsGoal)
            {
                ExpandCurrentNode(actions, goal);
                _current = Pop(); //Get next node.
            }

            if (_current == null) return null;
            return GetNodePlan(_current); //Se extrae el plan del nodo objetivo expandido.
        }
        
        //SortedNodes
        /// <summary>
        /// Extracts the first node to expand in the next iteration.
        /// </summary>
        /// <returns>First node to expand.</returns>
        private Node<TA, TB> Pop()
        {
            if (_openList.Count == 0) return null;
            Node<TA, TB> node = _openList[0];
            _openList.RemoveAt(0);
            Console.Out.WriteLine("Nodo extraido:\n" + node);
            return node;
        }

        private void ExpandCurrentNode(List<Base.Action<TA, TB>> actions, Goal<TA, TB> goal)
        {
            _expandedNodes.Add(_current);
            _expandedNodesCosts[_current] = _current.TotalCost;
            for (int i = 0; i < actions.Count; i++)
            {
                Node<TA, TB> aux = _current.ApplyAction(actions[i]);
                if(aux == null) continue;
                    
                
                aux.Update(_current.RealCost, goal);
                if (_expandedNodes.Contains(aux))
                {
                    //En caso de que el nodo expandido sea de menor coste, se reemplaza en la lista de nodos expandidos.
                    if (aux.TotalCost < _expandedNodesCosts[aux])
                    {
                        _expandedNodes.Add(aux);
                        _expandedNodesCosts[aux] = aux.TotalCost;
                    }
                }
                else
                    _openList.Add(aux);
            }
            _openList.Sort();
        }
        
        /// <summary>
        /// After reached the goal node, retrieves the plan associated with the node.
        /// </summary>
        /// <param name="nodeGoal">Node goal</param>
        /// <returns>Action plan generated by the planner</returns>
        public static List<Base.Action<TA, TB>> GetNodePlan(Node<TA, TB> nodeGoal)
        {
            List<Base.Action<TA, TB>> plan = new List<Base.Action<TA, TB>>(); 
            List<Base.Action<TA, TB>> invertedPlan = new List<Base.Action<TA, TB>>();
            while (nodeGoal.Parent != null)
            {
                invertedPlan.Add(nodeGoal.Action);
                nodeGoal = nodeGoal.Parent;
            }

            for (int i = invertedPlan.Count - 1; i >= 0; i--)
            {
                plan.Add(invertedPlan[i]);
            }

            return plan;
        }
    }
}