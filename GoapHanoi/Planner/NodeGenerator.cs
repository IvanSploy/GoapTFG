using System;
using System.Collections.Generic;
using System.Linq;
using GoapHanoi.Base;

namespace GoapHanoi.Planner
{
    public class NodeGenerator<TA, TB>
    {
        private Goal<TA, TB> _goal;
        private Node<TA, TB> _current;
        public readonly List<Node<TA, TB>> SortedNodes;

        public NodeGenerator(PropertyGroup<TA, TB> currentState, Goal<TA, TB> goal)
        {
            _current = new Node<TA, TB>(currentState);
            _goal = goal;
            SortedNodes = new List<Node<TA, TB>>();
        }

        /// <summary>
        /// Creates a plan that finds using A* the path that finds the cheapest way to reach it.
        /// </summary>
        public List<Base.Action<TA, TB>> CreatePlan(List<Base.Action<TA, TB>> actions)
        {
            while (!_current.IsGoal)
            {
                for (int i = 0; i < actions.Count; i++)
                {
                    Node<TA, TB> aux = _current.ApplyAction(actions[i]);
                    if(aux == null) continue;
                    
                    aux.Update(_goal);
                    SortedNodes.Add(aux);
                }
                SortedNodes.Sort();
                _current = Pop();
            }

            return GeneratePlan(_current); //Se extrae el plan del nodo objetivo expandido.
        }
        
        //SortedNodes
        /// <summary>
        /// Extracts the first node to expand in the next iteration.
        /// </summary>
        /// <returns>First node to expand.</returns>
        public Node<TA, TB> Pop()
        {
            Node<TA, TB> node = SortedNodes[0];
            SortedNodes.RemoveAt(0);
            return node;
        }

        /// <summary>
        /// After reached the goal node, retrieves the plan.
        /// </summary>
        /// <param name="nodeGoal">Node goal</param>
        /// <returns>Action plan generated by the planner</returns>
        public List<Base.Action<TA, TB>> GeneratePlan(Node<TA, TB> nodeGoal)
        {
            List<Base.Action<TA, TB>> plan = new List<Base.Action<TA, TB>>(); 
            List<Base.Action<TA, TB>> invertedPlan = new List<Base.Action<TA, TB>>();
            while (nodeGoal.Parent != null)
            {
                invertedPlan.Add(nodeGoal.Action);
                nodeGoal = nodeGoal.Parent;
            }

            for (int i = invertedPlan.Count; i >= 0; i--)
            {
                plan.Add(invertedPlan[i]);
            }

            return plan;
        }
    }
}