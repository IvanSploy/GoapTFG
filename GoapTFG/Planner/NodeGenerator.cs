using System;
using System.Collections.Generic;
using System.Linq;
using GoapTFG.Base;

namespace GoapTFG.Planner
{
    public class NodeGenerator<TA, TB>
    {
        private Goal<TA, TB> _goal;
        private Node<TA, TB> _current;
        public readonly List<Node<TA, TB>> OpenList;
        public readonly HashSet<Node<TA, TB>> ExpandedNodes;
        public readonly Dictionary<Node<TA, TB>, int> ExpandedNodesCosts;
        

        public NodeGenerator(PropertyGroup<TA, TB> currentState, Goal<TA, TB> goal)
        {
            _current = new Node<TA, TB>(currentState);
            _goal = goal;
            OpenList = new List<Node<TA, TB>>();
            ExpandedNodes = new HashSet<Node<TA, TB>>();
            ExpandedNodesCosts = new Dictionary<Node<TA, TB>, int>();
        }

        /// <summary>
        /// Creates a plan that finds using A* the path that finds the cheapest way to reach it.
        /// </summary>
        public List<Base.Action<TA, TB>> CreatePlan(List<Base.Action<TA, TB>> actions)
        {
            while (!_current.IsGoal)
            {
                ExpandCurrentNode(actions);
                _current = Pop(); //Get next node.
                Console.Out.WriteLine("Nodo actual:\n" + _current);
            }

            return GeneratePlan(_current); //Se extrae el plan del nodo objetivo expandido.
        }
        
        //SortedNodes
        /// <summary>
        /// Extracts the first node to expand in the next iteration.
        /// </summary>
        /// <returns>First node to expand.</returns>
        private Node<TA, TB> Pop()
        {
            Node<TA, TB> node = OpenList[0];
            OpenList.RemoveAt(0);
            return node;
        }

        private void ExpandCurrentNode(List<Base.Action<TA, TB>> actions)
        {
            ExpandedNodes.Add(_current);
            ExpandedNodesCosts[_current] = _current.TotalCost;
            for (int i = 0; i < actions.Count; i++)
            {
                Node<TA, TB> aux = _current.ApplyAction(actions[i]);
                if(aux == null) continue;
                    
                
                aux.Update(_current.RealCost, _goal);
                if (ExpandedNodes.Contains(aux))
                {
                    //En caso de que el nodo expandido sea de menor coste, se reemplaza en la lista de nodos expandidos.
                    if (aux.TotalCost < ExpandedNodesCosts[aux])
                    {
                        ExpandedNodes.Add(aux);
                        ExpandedNodesCosts[aux] = aux.TotalCost;
                    }
                }
                else
                    OpenList.Add(aux);
            }
            OpenList.Sort();
        }
        
        /// <summary>
        /// After reached the goal node, retrieves the plan.
        /// </summary>
        /// <param name="nodeGoal">Node goal</param>
        /// <returns>Action plan generated by the planner</returns>
        private List<Base.Action<TA, TB>> GeneratePlan(Node<TA, TB> nodeGoal)
        {
            List<Base.Action<TA, TB>> plan = new List<Base.Action<TA, TB>>(); 
            List<Base.Action<TA, TB>> invertedPlan = new List<Base.Action<TA, TB>>();
            while (nodeGoal.Parent != null)
            {
                invertedPlan.Add(nodeGoal.Action);
                nodeGoal = nodeGoal.Parent;
            }

            for (int i = invertedPlan.Count - 1; i >= 0; i--)
            {
                plan.Add(invertedPlan[i]);
            }

            return plan;
        }
    }
}